

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trikit.estimators.bootstrap &mdash; trikit 0.3.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> trikit
          

          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Project Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../triangle.html">Triangles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../estimators.html">Estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasets.html">Sample Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lrdb.html">CAS Loss Reserving Database</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/correlated.html">Correlated Reserve Indications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/smoothing.html">Smoothing Loss Development Patterns</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">trikit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>trikit.estimators.bootstrap</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for trikit.estimators.bootstrap</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">BootstrapChainLadder implementation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">RandomState</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">BaseRangeEstimator</span><span class="p">,</span> <span class="n">BaseRangeEstimatorResult</span>


<div class="viewcode-block" id="BootstrapChainLadder"><a class="viewcode-back" href="../../../trikit.estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder">[docs]</a><span class="k">class</span> <span class="nc">BootstrapChainLadder</span><span class="p">(</span><span class="n">BaseRangeEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The purpose of the bootstrap technique is to estimate the predicition</span>
<span class="sd">    error of the total reserve estimate and to approximate the predictive</span>
<span class="sd">    distribution. It is often impractical to obtain the prediction error</span>
<span class="sd">    using an analytical approach due to the complexity of reserve estimators.</span>

<span class="sd">    Predicition error is comprised of two components: process error</span>
<span class="sd">    and estimation error (Prediction Error = Estimation Error + Process Error).</span>
<span class="sd">    The estimation error (parameter error) represents the uncertainty in the</span>
<span class="sd">    parameter estimates given that the model is correctly specified. The</span>
<span class="sd">    process error is analogous to the variance of a random variable,</span>
<span class="sd">    representing the uncertainty in future outcomes.</span>

<span class="sd">    The procedure used to generate the predicitive distribution of reserve</span>
<span class="sd">    estimates is based on Leong et al. Appendix A, assuming the starting point</span>
<span class="sd">    is a triangle of cumulative losses:</span>

<span class="sd">    1.  Calculate the all-year volume-weighted age-to-age factors.</span>

<span class="sd">    2.  Estimate the fitted historical cumulative paid loss and ALAE</span>
<span class="sd">        using the latest diagonal of the original triangle and the</span>
<span class="sd">        age-to-age factors from [1] to un-develop the losses.</span>

<span class="sd">    3.  Calculate the unscaled Pearson residuals, degrees of freedom</span>
<span class="sd">        and scale parameter.</span>

<span class="sd">    4.  Calculate the adjusted Pearson residuals.</span>

<span class="sd">    5.  Sample with replacement from the adjusted Pearson residuals.</span>

<span class="sd">    6.  Calculate the triangle of sampled incremental losses</span>
<span class="sd">        (I^ = m + r_adj * sqrt(m)), where I^ = Resampled incremental loss,</span>
<span class="sd">        m = Incremental fitted loss (from [2]) and r_adj = Adjusted Pearson</span>
<span class="sd">        residuals.</span>

<span class="sd">    7.  Using the triangle from [6], project future losses using the</span>
<span class="sd">        Chain Ladder method.</span>

<span class="sd">    8.  Include Process variance by simulating each incremental future</span>
<span class="sd">        loss from a Gamma distribution with mean = I^ and</span>
<span class="sd">        variance = I^ * scale parameter.</span>

<span class="sd">    9.  Estimate unpaid losses using the Chain Ladder technique.</span>

<span class="sd">    10. Repeat for the number of cycles specified.</span>

<span class="sd">    The collection of projected ultimates for each origin year over all</span>
<span class="sd">    bootstrap cycles comprises the predictive distribtuion of reserve</span>
<span class="sd">    estimates.</span>
<span class="sd">    Note that the estimate of the distribution of losses assumes</span>
<span class="sd">    development is complete by the final development period. This is</span>
<span class="sd">    to avoid the complication associated with modeling a tail factor.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    1. England, P., and R. Verrall, (2002), *Stochastic Claims Reserving in General</span>
<span class="sd">       Insurance*, British Actuarial Journal 8(3): 443-518.</span>

<span class="sd">    2. CAS Working Party on Quantifying Variability in Reserve Estimates,</span>
<span class="sd">       *The Analysis and Estimation of Loss &amp; ALAE Variability: A Summary Report*,</span>
<span class="sd">       Casualty Actuarial Society Forum, Fall 2005.</span>

<span class="sd">    3. Leong et al., (2012), *Back-Testing the ODP Bootstrap of the Paid</span>
<span class="sd">       Chain-Ladder Model with Actual Historical Claims Data*, Casualty Actuarial</span>
<span class="sd">       Society E-Forum.</span>

<span class="sd">    4. Kirschner, et al., *Two Approaches to Calculating Correlated Reserve</span>
<span class="sd">       Indications Across Multiple Lines of Business* Appendix III, Variance</span>
<span class="sd">       Journal, Volume 2/Issue 1.</span>

<span class="sd">    5. Shapland, Mark R., (2016), *Using the ODP Bootstrap Model: A</span>
<span class="sd">       Practicioner&#39;s Guide*, CAS Monograph Series Number 4: Casualty Actuarial</span>
<span class="sd">       Society, 2016.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cumtri</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The BootstrapChainLadder class definition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cumtri: triangle.CumTriangle</span>
<span class="sd">            A cumulative triangle instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cumtri</span><span class="o">=</span><span class="n">cumtri</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dfrlvi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dof</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">75</span><span class="p">,</span> <span class="o">.</span><span class="mi">95</span><span class="p">],</span> <span class="n">procdist</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">parametric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">two_sided</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``BootstrapChainLadder`` simulation initializer. Generates predictive</span>
<span class="sd">        distribution of reserve outcomes by origin and in total.</span>

<span class="sd">        The estimated distribution of losses assumes development is complete</span>
<span class="sd">        by the final development period in order to avoid the complication of</span>
<span class="sd">        modeling a tail factor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sims: int</span>
<span class="sd">            The number of bootstrap simulations to perform. Defaults to 1000.</span>

<span class="sd">        q: array_like of float or float</span>
<span class="sd">            Quantile or sequence of quantiles to compute, which must be</span>
<span class="sd">            between 0 and 1 inclusive.</span>

<span class="sd">        procdist: str</span>
<span class="sd">            The distribution used to incorporate process variance. Currently,</span>
<span class="sd">            this can only be set to &quot;gamma&quot;.</span>

<span class="sd">        two_sided: bool</span>
<span class="sd">            Whether the two_sided interval should be included in summary</span>
<span class="sd">            output. For example, if ``two_sided==True`` and ``q=.95``, then</span>
<span class="sd">            the 2.5th and 97.5th quantiles of the bootstrapped reserve</span>
<span class="sd">            distribution will be returned [(1 - .95) / 2, (1 + .95) / 2]. When</span>
<span class="sd">            False, only the specified quantile(s) will be computed. Defaults</span>
<span class="sd">            to False.</span>

<span class="sd">        parametric: bool</span>
<span class="sd">            If True, fit standardized residuals to a normal distribution, and</span>
<span class="sd">            sample from this parameterized distribution. Otherwise, bootstrap</span>
<span class="sd">            procedure samples with replacement from the collection of</span>
<span class="sd">            standardized residuals. Defaults to False.</span>

<span class="sd">        interpolation: {&quot;linear&quot;, &quot;lower&quot;, &quot;higher&quot;, &quot;midpoint&quot;, &quot;nearest&quot;}</span>
<span class="sd">            This optional parameter specifies the interpolation method to use</span>
<span class="sd">            when the desired quantile lies between two data points i &lt; j. See</span>
<span class="sd">            ``numpy.quantile`` for more information. Default value is &quot;linear&quot;.</span>

<span class="sd">        random_state: np.random.RandomState</span>
<span class="sd">            If int, random_state is the seed used by the random number</span>
<span class="sd">            generator; If RandomState instance, random_state is the random</span>
<span class="sd">            number generator; If None, the random number generator is the</span>
<span class="sd">            RandomState instance used by np.random.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BootstrapChainLadderResult</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ldfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ldfs</span><span class="p">(</span><span class="n">sel</span><span class="o">=</span><span class="s2">&quot;all-weighted&quot;</span><span class="p">)</span>
        <span class="n">cldfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cldfs</span><span class="p">(</span><span class="n">ldfs</span><span class="o">=</span><span class="n">ldfs</span><span class="p">)</span>
        <span class="n">maturity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">maturity</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">latest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">latest_by_origin</span>
        <span class="n">trisqrd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trisqrd</span><span class="p">(</span><span class="n">ldfs</span><span class="o">=</span><span class="n">ldfs</span><span class="p">)</span>

        <span class="c1"># Obtain reference to BootstrapChainLadder estimates.</span>
        <span class="n">tri_fit_cum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri_fit_cum</span><span class="p">(</span><span class="n">ldfs</span><span class="o">=</span><span class="n">ldfs</span><span class="p">)</span>
        <span class="n">tri_fit_incr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri_fit_incr</span><span class="p">(</span><span class="n">fitted_tri_cum</span><span class="o">=</span><span class="n">tri_fit_cum</span><span class="p">)</span>
        <span class="n">unscld_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resid_us</span><span class="p">(</span><span class="n">fitted_tri_incr</span><span class="o">=</span><span class="n">tri_fit_incr</span><span class="p">)</span>
        <span class="n">adjust_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resid_adj</span><span class="p">(</span><span class="n">resid_us</span><span class="o">=</span><span class="n">unscld_residuals</span><span class="p">)</span>
        <span class="n">scale_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_param</span><span class="p">(</span><span class="n">resid_us</span><span class="o">=</span><span class="n">unscld_residuals</span><span class="p">)</span>
        <span class="n">sampling_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_dist</span><span class="p">(</span><span class="n">resid_adj</span><span class="o">=</span><span class="n">adjust_residuals</span><span class="p">)</span>
        <span class="n">dfsamples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bs_samples</span><span class="p">(</span>
            <span class="n">sampling_dist</span><span class="o">=</span><span class="n">sampling_dist</span><span class="p">,</span> <span class="n">fitted_tri_incr</span><span class="o">=</span><span class="n">tri_fit_incr</span><span class="p">,</span>
            <span class="n">sims</span><span class="o">=</span><span class="n">sims</span><span class="p">,</span> <span class="n">parametric</span><span class="o">=</span><span class="n">parametric</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
            <span class="p">)</span>
        <span class="n">dfldfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bs_ldfs</span><span class="p">(</span><span class="n">dfsamples</span><span class="o">=</span><span class="n">dfsamples</span><span class="p">)</span>
        <span class="n">dfforecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bs_forecasts</span><span class="p">(</span><span class="n">dfsamples</span><span class="p">,</span> <span class="n">dfldfs</span><span class="p">,</span> <span class="n">scale_param</span><span class="p">)</span>
        <span class="n">dfprocerror</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bs_process_error</span><span class="p">(</span>
            <span class="n">dfforecasts</span><span class="o">=</span><span class="n">dfforecasts</span><span class="p">,</span> <span class="n">scale_param</span><span class="o">=</span><span class="n">scale_param</span><span class="p">,</span> <span class="n">procdist</span><span class="o">=</span><span class="n">procdist</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
            <span class="p">)</span>

        <span class="n">dfreserves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bs_reserves</span><span class="p">(</span><span class="n">dfprocerror</span><span class="o">=</span><span class="n">dfprocerror</span><span class="p">)</span>
        <span class="n">ultimates</span> <span class="o">=</span> <span class="n">dfreserves</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;origin&quot;</span><span class="p">])[</span><span class="s2">&quot;ultimate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">ultimates</span><span class="p">[</span><span class="n">latest</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="o">=</span> <span class="n">latest</span><span class="p">[</span><span class="n">latest</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span>
        <span class="n">reserves</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ultimates</span> <span class="o">-</span> <span class="n">latest</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reserve&quot;</span><span class="p">)</span>
        <span class="n">std_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bs_std_error</span><span class="p">(</span><span class="n">dfreserves</span><span class="p">)</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">std_error</span> <span class="o">/</span> <span class="n">reserves</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cv&quot;</span><span class="p">)</span>
        <span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qtls_formatter</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">two_sided</span><span class="o">=</span><span class="n">two_sided</span><span class="p">)</span>

        <span class="c1"># Compile Chain Ladder point estimate summary.</span>
        <span class="n">dfmatur</span> <span class="o">=</span> <span class="n">maturity</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;origin&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfcldfs</span> <span class="o">=</span> <span class="n">cldfs</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;maturity&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfcldfs</span><span class="p">[</span><span class="s2">&quot;maturity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfcldfs</span><span class="p">[</span><span class="s2">&quot;maturity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">dfcldfs</span><span class="p">[</span><span class="s2">&quot;emergence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dfcldfs</span><span class="p">[</span><span class="s2">&quot;cldf&quot;</span><span class="p">]</span>
        <span class="n">dfsumm</span> <span class="o">=</span> <span class="n">dfmatur</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dfcldfs</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;maturity&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">)</span>
        <span class="n">dfsumm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dflatest</span> <span class="o">=</span> <span class="n">latest</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;latest_by_origin&quot;</span><span class="p">:</span> <span class="s2">&quot;latest&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfsumm</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">:</span> <span class="n">df1</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df2</span><span class="p">),</span>
            <span class="p">(</span><span class="n">dflatest</span><span class="p">,</span> <span class="n">ultimates</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(),</span> <span class="n">reserves</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(),</span> <span class="n">std_error</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(),</span> <span class="n">cv</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()),</span>
            <span class="n">dfsumm</span>
            <span class="p">)</span>

        <span class="c1"># Add &quot;Total&quot; index and set to NaN fields that shouldn&#39;t be aggregated.</span>
        <span class="n">dfsumm</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfsumm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">dfsumm</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">,</span> <span class="s2">&quot;maturity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">dfsumm</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;cldf&quot;</span><span class="p">,</span> <span class="s2">&quot;emergence&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">dfsumm</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">,</span> <span class="s2">&quot;std_error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_error</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span>
        <span class="n">dfsumm</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">,</span> <span class="s2">&quot;cv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_error</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dfsumm</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">,</span> <span class="s2">&quot;reserve&quot;</span><span class="p">]</span>

        <span class="c1"># Attach quantiles.</span>
        <span class="n">dftotal_res</span> <span class="o">=</span> <span class="n">dfreserves</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">dftotal_res</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;total&quot;</span>
        <span class="n">dfreserves</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dfreserves</span><span class="p">,</span> <span class="n">dftotal_res</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">):</span>
            <span class="n">dfsumm</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfsumm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
                    <span class="n">dfreserves</span><span class="p">[</span><span class="n">dfreserves</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">v</span><span class="p">][</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="mi">100</span> <span class="o">*</span> <span class="n">ii</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="n">bcl_result</span> <span class="o">=</span> <span class="n">BootstrapChainLadderResult</span><span class="p">(</span>
            <span class="n">summary</span><span class="o">=</span><span class="n">dfsumm</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="p">,</span> <span class="n">ldfs</span><span class="o">=</span><span class="n">ldfs</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">trisqrd</span><span class="o">=</span><span class="n">trisqrd</span><span class="p">,</span>
            <span class="n">reserve_dist</span><span class="o">=</span><span class="n">dfreserves</span><span class="p">,</span> <span class="n">sims_data</span><span class="o">=</span><span class="n">dfprocerror</span><span class="p">,</span> <span class="n">scale_param</span><span class="o">=</span><span class="n">scale_param</span><span class="p">,</span>
            <span class="n">dof</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">,</span> <span class="n">unscaled_residuals</span><span class="o">=</span><span class="n">unscld_residuals</span><span class="p">,</span>
            <span class="n">adjusted_residuals</span><span class="o">=</span><span class="n">adjust_residuals</span><span class="p">,</span>
            <span class="n">sampling_dist</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">parametric</span> <span class="k">else</span> <span class="n">sampling_dist</span><span class="p">,</span>
            <span class="n">fitted_tri_cum</span><span class="o">=</span><span class="n">tri_fit_cum</span><span class="p">,</span> <span class="n">fitted_tri_incr</span><span class="o">=</span><span class="n">tri_fit_incr</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="n">sims</span><span class="p">,</span>
            <span class="n">procdist</span><span class="o">=</span><span class="n">procdist</span><span class="p">,</span> <span class="n">parametric</span><span class="o">=</span><span class="n">parametric</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span>
            <span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">bcl_result</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dfrlvi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform triangle&#39;s last valid origin index into DataFrame format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfrlvi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">rlvi</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="s2">&quot;l_act_dev&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dfrlvi</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;col_offset&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dfrlvi</span><span class="p">)</span>


<div class="viewcode-block" id="BootstrapChainLadder._get_dfcombined"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._get_dfcombined">[docs]</a>    <span class="k">def</span> <span class="nf">_get_dfcombined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfsamples</span><span class="p">,</span> <span class="n">dfldfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge output of ``self._bs_samples`` and ``self._bs_ldfs``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dfsamples: pd.DataFrame</span>
<span class="sd">            Output from ``self._bs_samples``.</span>

<span class="sd">        dfldfs: pd.DataFrame</span>
<span class="sd">            Output from ``self._bs_ldfs``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dfcombined</span> <span class="o">=</span> <span class="n">dfsamples</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dfldfs</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">dfcombined</span> <span class="o">=</span> <span class="n">dfcombined</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfrlvi</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfcombined</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">]))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the degress of freedom.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">nbr_cells</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dof</span><span class="p">)</span>


<div class="viewcode-block" id="BootstrapChainLadder._scale_param"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._scale_param">[docs]</a>    <span class="k">def</span> <span class="nf">_scale_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid_us</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the scale parameter, which is the sum of the squared unscaled</span>
<span class="sd">        Pearson residuals over the degrees of freedom. This method is intended</span>
<span class="sd">        for internal use only.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resid_us: pd.DataFrame</span>
<span class="sd">            Unscaled Pearson residuals, typically output by</span>
<span class="sd">            ``self._resid_us``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">((</span><span class="n">resid_us</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._tri_fit_cum"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._tri_fit_cum">[docs]</a>    <span class="k">def</span> <span class="nf">_tri_fit_cum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ldfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative fitted triangle using backwards recursion,</span>
<span class="sd">        starting with the observed cumulative paid/incurred-to-date along the</span>
<span class="sd">        latest diagonal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ldfs: pd.Series</span>
<span class="sd">            Selected ldfs, typically the output of calling ``self._ldfs``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fitted_tri_cum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">iterrow</span> <span class="o">=</span> <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">iterrow</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># Find first NaN element in iterrow.</span>
                <span class="n">nan_hdr</span> <span class="o">=</span> <span class="n">iterrow</span><span class="o">.</span><span class="n">isnull</span><span class="p">()[</span><span class="n">iterrow</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nan_idx</span> <span class="o">=</span> <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nan_hdr</span><span class="p">)</span>
                <span class="n">init_idx</span> <span class="o">=</span> <span class="n">nan_idx</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If here, iterrow is the most mature exposure period.</span>
                <span class="n">init_idx</span> <span class="o">=</span> <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Set to NaN any development periods earlier than init_idx.</span>
            <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:</span><span class="n">init_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

            <span class="c1"># Iterate over rows, undeveloping triangle from latest diagonal.</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:</span><span class="n">init_idx</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">prev_col_idx</span><span class="p">,</span> <span class="n">curr_col_idx</span><span class="p">,</span> <span class="n">curr_ldf_idx</span> <span class="o">=</span> <span class="n">jj</span><span class="p">,</span> <span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">prev_col_val</span> <span class="o">=</span> <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">prev_col_idx</span><span class="p">]</span>
                <span class="n">curr_ldf_val</span> <span class="o">=</span> <span class="n">ldfs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">curr_ldf_idx</span><span class="p">]</span>
                <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">curr_col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev_col_val</span> <span class="o">/</span> <span class="n">curr_ldf_val</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">fitted_tri_cum</span><span class="p">)</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._tri_fit_incr"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._tri_fit_incr">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_tri_fit_incr</span><span class="p">(</span><span class="n">fitted_tri_cum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a fitted incremental triangle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fitted_tri_cum: pd.DataFrame</span>
<span class="sd">            Typically the output from ``self._tri_fit_cum``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tri</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitted_tri_cum</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._resid_us"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._resid_us">[docs]</a>    <span class="k">def</span> <span class="nf">_resid_us</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitted_tri_incr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return unscaled Pearson residuals, given by</span>
<span class="sd">        :math:`r_{us} = \\frac{I - m}{\\sqrt{|m|}}`, where :math:`r_{us}` represents the</span>
<span class="sd">        unscaled Pearson residuals, :math:`I` the actual incremental losses and :math:`m`</span>
<span class="sd">        fitted incremental losses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fitted_tri_incr: pd.DataFrame</span>
<span class="sd">            Typically the output from ``self._tri_fit_incr``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># I represents actual incremental losses, m fitted incremental losses.</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">to_incr</span><span class="p">())</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">fitted_tri_incr</span>
        <span class="k">return</span><span class="p">((</span><span class="n">I</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">abs</span><span class="p">()))</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._resid_adj"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._resid_adj">[docs]</a>    <span class="k">def</span> <span class="nf">_resid_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid_us</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute and return the adjusted Pearson residuals, given by</span>
<span class="sd">        :math:`r_{adj} = \\sqrt{\\frac{N}{dof}} * r_{us}`, where *r_adj*</span>
<span class="sd">        represents the adjusted Pearson residuals, *N* the number of triangle cells,</span>
<span class="sd">        *dof* the degress of freedom and *r_us* the unscaled Pearson residuals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resid_us: pd.DataFrame</span>
<span class="sd">            Unscaled Pearson residuals, typically output by ``self._resid_us``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">nbr_cells</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span> <span class="o">*</span> <span class="n">resid_us</span><span class="p">)</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._sampling_dist"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._sampling_dist">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sampling_dist</span><span class="p">(</span><span class="n">resid_adj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``resid_adj`` as a 1-dimensional array, which will be sampled</span>
<span class="sd">        from with replacement in order to produce synthetic triangles for</span>
<span class="sd">        bootstrapping. Any NaN&#39;s and 0&#39;s present in ``resid_adj`` will not be</span>
<span class="sd">        present in the returned array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resid_adj: pd.DataFrame</span>
<span class="sd">            Adjusted Pearson residuals, typically output by ``self._resid_adj``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resid_</span> <span class="o">=</span> <span class="n">resid_adj</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span><span class="p">(</span><span class="n">resid_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resid_</span><span class="p">),</span> <span class="n">resid_</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)])</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._bs_samples"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._bs_samples">[docs]</a>    <span class="k">def</span> <span class="nf">_bs_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_dist</span><span class="p">,</span> <span class="n">fitted_tri_incr</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">parametric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return DataFrame containing sims resampled-with-replacement</span>
<span class="sd">        incremental loss triangles if ``parametric=False``, otherwise</span>
<span class="sd">        random variates from a normal distribution with mean zero and</span>
<span class="sd">        variance derived from ``resid_adj``. Randomly generated incremental</span>
<span class="sd">        data gets cumulated in preparation for ldf calculation in next</span>
<span class="sd">        step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampling_dist: np.ndarray</span>
<span class="sd">            The residuals from the fitted incremental triangle coerced</span>
<span class="sd">            into a one-dimensional numpy array.</span>

<span class="sd">        fitted_tri_incr: pd.DataFrame</span>
<span class="sd">            The incremental triangle fitted using backwards recursion.</span>
<span class="sd">            Typically the output of ``self._tri_fit_incr``.</span>

<span class="sd">        sims: int</span>
<span class="sd">            The number of bootstrap simulations to run. Defaults to 1000.</span>

<span class="sd">        parametric: bool</span>
<span class="sd">            If True, fit standardized residuals to a normal distribution, and</span>
<span class="sd">            sample from the parameterized distribution. Otherwise, bootstrap</span>
<span class="sd">            procedure proceeds by sampling with replacement from the array</span>
<span class="sd">            of standardized residuals. Defaults to False.</span>

<span class="sd">        random_state: np.random.RandomState</span>
<span class="sd">            If int, random_state is the seed used by the random number</span>
<span class="sd">            generator; If RandomState instance, random_state is the random</span>
<span class="sd">            number generator; If None, the random number generator is the</span>
<span class="sd">            RandomState instance used by np.random.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">RandomState</span><span class="p">):</span>
                <span class="n">prng</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">()</span>

        <span class="n">sampling_dist</span> <span class="o">=</span> <span class="n">sampling_dist</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">fti</span> <span class="o">=</span> <span class="n">fitted_tri_incr</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;origin&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">fti</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
        <span class="n">dfm</span> <span class="o">=</span> <span class="n">dfm</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dfm</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])]</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s2">&quot;origin&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">})</span>

        <span class="c1"># Make positive any first development period negative values.</span>
        <span class="n">min_devp</span> <span class="o">=</span> <span class="n">dfm</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">dfm</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dfm</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">min_devp</span><span class="p">,</span> <span class="n">dfm</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span>
            <span class="mf">1.</span><span class="p">,</span> <span class="n">dfm</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>

        <span class="n">dfi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">to_tbl</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfp</span> <span class="o">=</span> <span class="n">dfi</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dfm</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">])</span>
        <span class="n">dfp</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dfp</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="s2">&quot;forecast&quot;</span><span class="p">,</span> <span class="s2">&quot;actual&quot;</span><span class="p">)</span>
        <span class="n">dfp</span> <span class="o">=</span> <span class="n">dfp</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;incr&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfp</span><span class="p">[</span><span class="s2">&quot;incr_sqrt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dfp</span><span class="p">[</span><span class="s2">&quot;incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">dfrtypes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;origin&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;incr&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                   <span class="s2">&quot;incr_sqrt&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;rectype&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
        <span class="n">dfrcols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;incr&quot;</span><span class="p">,</span> <span class="s2">&quot;rectype&quot;</span><span class="p">,</span> <span class="s2">&quot;incr_sqrt&quot;</span><span class="p">]</span>

        <span class="c1"># Replicate dfp sims times then redefine datatypes.</span>
        <span class="n">dfr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">dfp</span><span class="p">,</span> <span class="p">(</span><span class="n">sims</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">columns</span><span class="o">=</span><span class="n">dfrcols</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dfrtypes</span><span class="p">)</span>

        <span class="c1"># Assign simulation identifier to each record in dfr.</span>
        <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">dfr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sample_size</span> <span class="o">=</span> <span class="n">dfr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">parametric</span><span class="p">:</span>
            <span class="c1"># Sample random standard normal residuals.</span>
            <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;resid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sampling_dist</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Randomly sample residuals from sampling_dist.</span>
            <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;resid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sampling_dist</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Calcuate resampled incremental and cumulative losses.</span>
        <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;resid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="s2">&quot;forecast&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;resid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">dfr</span> <span class="o">=</span> <span class="n">dfr</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;samp_incr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;resid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;incr_sqrt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">dfr</span><span class="p">[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfr</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="s2">&quot;samp_incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfr</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._bs_ldfs"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._bs_ldfs">[docs]</a>    <span class="k">def</span> <span class="nf">_bs_ldfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfsamples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute and return loss development factors for each set of synthetic</span>
<span class="sd">        loss data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dfsamples: pd.DataFrame</span>
<span class="sd">            Output from ``self._bs_samples``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keepcols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;samp_cum&quot;</span><span class="p">,</span> <span class="s2">&quot;last_origin&quot;</span><span class="p">]</span>
        <span class="n">new_col_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">:</span> <span class="s2">&quot;last_origin&quot;</span><span class="p">,</span> <span class="s2">&quot;row_offset&quot;</span><span class="p">:</span> <span class="s2">&quot;origin_offset&quot;</span><span class="p">}</span>
        <span class="n">dflvi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri</span><span class="o">.</span><span class="n">clvi</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">new_col_names</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfinit</span> <span class="o">=</span> <span class="n">dfsamples</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dflvi</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">])</span>
        <span class="n">dfinit</span> <span class="o">=</span> <span class="n">dfinit</span><span class="p">[</span><span class="n">keepcols</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">dfinit</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dfinit</span><span class="p">[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">])]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;_aggdev2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;last_origin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">,</span> <span class="s2">&quot;_aggdev2&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">:</span> <span class="s2">&quot;_aggdev1&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">df2</span><span class="p">[</span><span class="s2">&quot;_aggdev2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="s2">&quot;_aggdev2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">df2</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfldfs</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="n">df2</span><span class="p">[</span><span class="s2">&quot;_aggdev2&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">)</span>
        <span class="n">dfldfs</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfldfs</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">dfldfs</span><span class="p">[</span><span class="s2">&quot;ldf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfldfs</span><span class="p">[</span><span class="s2">&quot;_aggdev1&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dfldfs</span><span class="p">[</span><span class="s2">&quot;_aggdev2&quot;</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfldfs</span><span class="p">[[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;ldf&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._bs_forecasts"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._bs_forecasts">[docs]</a>    <span class="k">def</span> <span class="nf">_bs_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfsamples</span><span class="p">,</span> <span class="n">dfldfs</span><span class="p">,</span> <span class="n">scale_param</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate lower-right of each simulated triangle using values from</span>
<span class="sd">        ``self._bs_samples`` and development factors from ``self._bs_ldfs``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dfsamples: pd.DataFrame</span>
<span class="sd">            Output from ``self._bs_samples``.</span>

<span class="sd">        dfldfs: pd.DataFrame</span>
<span class="sd">            Output from ``self._bs_ldfs``.</span>

<span class="sd">        scale_param: float</span>
<span class="sd">            the sum of the squared unscaled Pearson residuals over the</span>
<span class="sd">            degrees of freedom. Output from ``self._scale_param``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dfcombined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dfcombined</span><span class="p">(</span><span class="n">dfsamples</span><span class="p">,</span> <span class="n">dfldfs</span><span class="p">)</span>
        <span class="n">min_origin_year</span> <span class="o">=</span> <span class="n">dfcombined</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">dfcombined</span><span class="p">[</span><span class="s2">&quot;_l_init_indx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">dfcombined</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;=</span> <span class="n">dfcombined</span><span class="p">[</span><span class="s2">&quot;l_act_dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">dfcombined</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="n">dfacts</span> <span class="o">=</span> <span class="n">dfcombined</span><span class="p">[(</span><span class="n">dfcombined</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">min_origin_year</span><span class="p">)</span> <span class="o">|</span>
                            <span class="p">(</span><span class="n">dfcombined</span><span class="p">[</span><span class="s2">&quot;_l_init_indx&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="n">dffcst</span> <span class="o">=</span> <span class="n">dfcombined</span><span class="p">[</span><span class="o">~</span><span class="n">dfcombined</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dfacts</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
            <span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">])</span>
        <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_l_act_indx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dffcst</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">])[</span><span class="s2">&quot;_l_init_indx&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">)</span>
        <span class="n">l_act_cum</span> <span class="o">=</span> <span class="n">dffcst</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_l_act_indx&quot;</span><span class="p">],</span> <span class="s2">&quot;samp_cum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;l_act_cum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_act_cum</span>
        <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_cum_ldf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dffcst</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">])[</span><span class="s2">&quot;ldf&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="s2">&quot;cumprod&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_samp_cum2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;l_act_cum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_cum_ldf&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_samp_cum2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_samp_cum2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_samp_cum2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
        <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;cum_final&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="n">dffcst</span><span class="p">[</span><span class="s2">&quot;_samp_cum2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># Combine forecasts with actuals then compute incremental losses by sim and origin.</span>
        <span class="n">dffcst</span> <span class="o">=</span> <span class="n">dffcst</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">,</span> <span class="s2">&quot;samp_incr&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cum_final&quot;</span><span class="p">:</span> <span class="s2">&quot;samp_cum&quot;</span><span class="p">})</span>
        <span class="n">dfsqrd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dffcst</span><span class="p">,</span> <span class="n">dfacts</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
            <span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">])</span>
        <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_dev1_ind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
        <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_incr_dev1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_dev1_ind&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_incr_dev2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfsqrd</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">])[</span><span class="s2">&quot;samp_cum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_incr_dev2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_incr_dev2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_incr_dev2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
        <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;samp_incr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_incr_dev1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;_incr_dev2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;samp_incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">scale_param</span><span class="p">)</span>
        <span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;sign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfsqrd</span><span class="p">[</span><span class="s2">&quot;samp_incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfsqrd</span> <span class="o">=</span> <span class="n">dfsqrd</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">dfsqrd</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">ii</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfsqrd</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._bs_process_error"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._bs_process_error">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bs_process_error</span><span class="p">(</span><span class="n">dfforecasts</span><span class="p">,</span> <span class="n">scale_param</span><span class="p">,</span> <span class="n">procdist</span><span class="o">=</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incorporate process error by simulating each incremental future</span>
<span class="sd">        loss from ``procdist``. The mean is set to the forecast incremental</span>
<span class="sd">        loss amount and variance to `mean x self.scale_param`.</span>
<span class="sd">        The parameters for ``procdist`` must be positive. Since the mean</span>
<span class="sd">        and variance used to parameterize ``procdist`` depend on the</span>
<span class="sd">        resampled incremental losses, it is necessary to incorporate logic</span>
<span class="sd">        to address the possibility of negative incremental losses arising</span>
<span class="sd">        in the resampling stage. The approach used to handle negative</span>
<span class="sd">        incremental values is described in  Shapland[1], and replaces the</span>
<span class="sd">        distribution mean with the absolute value of the mean, and the</span>
<span class="sd">        variance with the absolute value of the mean multiplied by ``scale_param``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dfforecasts: pd.DataFrame</span>
<span class="sd">            DateFrame of bootstraps forecasts generated within</span>
<span class="sd">            ``self._bs_forecasts``.</span>

<span class="sd">        scale_param: float</span>
<span class="sd">            the sum of the squared unscaled Pearson residuals over the</span>
<span class="sd">            degrees of freedom. Available in ``self._scale_param``.</span>

<span class="sd">        procdist: str</span>
<span class="sd">            Specifies the distribution used to incorporate process error.</span>
<span class="sd">            Currently, can only be set to &quot;gamma&quot;. Any other distribution</span>
<span class="sd">            will result in an error.</span>

<span class="sd">        random_state: np.random.RandomState</span>
<span class="sd">            If int, random_state is the seed used by the random number</span>
<span class="sd">            generator; If RandomState instance, random_state is the random</span>
<span class="sd">            number generator; If None, the random number generator is the</span>
<span class="sd">            RandomState instance used by np.random.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize pseudo random number generator.</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">RandomState</span><span class="p">):</span>
                <span class="n">prng</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">()</span>

        <span class="c1"># Parameterize distribution for the incorporation of process variance.</span>
        <span class="k">if</span> <span class="n">procdist</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span>
            <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;param2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_param</span>
            <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;param1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;samp_incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;param2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">fdist</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                gamma.rvs(a=param1, scale=param2, size=1, random_state=None)</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span><span class="p">(</span><span class="n">prng</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid procdist specification: `</span><span class="si">{}</span><span class="s2">`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">procdist</span><span class="p">))</span>

        <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;final_incr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="s2">&quot;forecast&quot;</span><span class="p">,</span>
            <span class="n">fdist</span><span class="p">(</span><span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;param1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;param2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;sign&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;samp_incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
        <span class="n">dfforecasts</span><span class="p">[</span><span class="s2">&quot;final_cum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfforecasts</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">])[</span><span class="s2">&quot;final_incr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="n">dfforecasts</span> <span class="o">=</span> <span class="n">dfforecasts</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;final_cum&quot;</span><span class="p">:</span> <span class="s2">&quot;ultimate&quot;</span><span class="p">,</span> <span class="s2">&quot;l_act_cum&quot;</span><span class="p">:</span> <span class="s2">&quot;latest&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfforecasts</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._bs_reserves"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._bs_reserves">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bs_reserves</span><span class="p">(</span><span class="n">dfprocerror</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute unpaid loss reserve estimate using output from</span>
<span class="sd">        ``self._bs_process_error``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dfprocerror: pd.DataFrame</span>
<span class="sd">            Output from ``self._bs_process_error``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keepcols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;latest&quot;</span><span class="p">,</span> <span class="s2">&quot;ultimate&quot;</span><span class="p">,</span> <span class="s2">&quot;reserve&quot;</span><span class="p">]</span>
        <span class="n">max_devp</span> <span class="o">=</span> <span class="n">dfprocerror</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">dfprocerror</span><span class="p">[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfprocerror</span><span class="p">[</span><span class="s2">&quot;ultimate&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dfprocerror</span><span class="p">[</span><span class="s2">&quot;latest&quot;</span><span class="p">]</span>
        <span class="n">dfreserves</span> <span class="o">=</span> <span class="n">dfprocerror</span><span class="p">[</span><span class="n">dfprocerror</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">max_devp</span><span class="p">][</span><span class="n">keepcols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="n">dfreserves</span><span class="p">[</span><span class="s2">&quot;latest&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dfreserves</span><span class="p">[</span><span class="s2">&quot;latest&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
            <span class="n">dfreserves</span><span class="p">[</span><span class="s2">&quot;ultimate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dfreserves</span><span class="p">[</span><span class="s2">&quot;latest&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>
        <span class="n">dfreserves</span><span class="p">[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">dfreserves</span><span class="p">[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfreserves</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;sim&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="BootstrapChainLadder._bs_std_error"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadder._bs_std_error">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bs_std_error</span><span class="p">(</span><span class="n">dfreserves</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute standard error of bootstrapped reserves by origin and in aggregate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dfreserves: pd.DataFrame</span>
<span class="sd">            Output from ``self._bs_reserves``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute standard deviation of bootstrap samples by origin.</span>
        <span class="n">dforigin_std</span> <span class="o">=</span> <span class="n">dfreserves</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;origin&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">origin_se</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">dforigin_std</span><span class="p">[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dforigin_std</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;std_error&quot;</span><span class="p">)</span>
        <span class="n">dftotal</span> <span class="o">=</span> <span class="n">dfreserves</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sim&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">total_se</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">dftotal</span><span class="p">[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;std_error&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">origin_se</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_se</span><span class="p">))</span></div></div>



<div class="viewcode-block" id="BootstrapChainLadderResult"><a class="viewcode-back" href="../../../trikit.estimators.html#trikit.estimators.bootstrap.BootstrapChainLadderResult">[docs]</a><span class="k">class</span> <span class="nc">BootstrapChainLadderResult</span><span class="p">(</span><span class="n">BaseRangeEstimatorResult</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container class for ``BootstrapChainLadder`` output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    summary: pd.DataFrame</span>
<span class="sd">        Chain Ladder summary compilation.</span>

<span class="sd">    reserve_dist: pd.DataFrame</span>
<span class="sd">        The predicitive distribution of reserve estimates generated via</span>
<span class="sd">        bootstrapping. ``reserve_dist`` is a five column DataFrame</span>
<span class="sd">        consisting of the simulation number, origin period, the latest</span>
<span class="sd">        loss amount for the associated origin period, and the predictive</span>
<span class="sd">        distribution of ultimates and reserves.</span>

<span class="sd">    sims_data: pd.DataFrame</span>
<span class="sd">        A DataFrame consiting of all simulated values an intermediate</span>
<span class="sd">        fields. When a large number of bootstrap iterations are run,</span>
<span class="sd">        ``sims_data`` will be correspondingly large. The fields include:</span>

<span class="sd">            - dev:</span>
<span class="sd">                The simulated development period.</span>

<span class="sd">            - incr:</span>
<span class="sd">                The actual incremental loss amount obtain from the fitted triangle.</span>

<span class="sd">            - incr_sqrt:</span>
<span class="sd">                The square root of incr.</span>

<span class="sd">            - l_act_cum:</span>
<span class="sd">                The latest actual cumulative loss amount for dev/origin.</span>

<span class="sd">            - l_act_dev:</span>
<span class="sd">                The latest dev period with actual losses for a given origin period.</span>

<span class="sd">            - ldf:</span>
<span class="sd">                Loss development factors computed on syntehtic triangle data.</span>

<span class="sd">            - origin:</span>
<span class="sd">                The simulated origin period.</span>

<span class="sd">            - rectype:</span>
<span class="sd">                Whether the dev/origin combination represent actual or forecast data</span>
<span class="sd">                in the squared triangle.</span>

<span class="sd">            - resid:</span>
<span class="sd">                The resampled adjusted residuals if ``parametric=False``, otherwise a</span>
<span class="sd">                random sampling from a normal distribution with mean zero and variance</span>
<span class="sd">                based on the variance of the adjusted residuals.</span>

<span class="sd">            - samp_cum:</span>
<span class="sd">                A syntehtic cumulative loss amount.</span>

<span class="sd">            - samp_incr:</span>
<span class="sd">                A synthetic incremental loss amount.</span>

<span class="sd">            - sim:</span>
<span class="sd">                Bootstrap iteration.</span>

<span class="sd">            - var:</span>
<span class="sd">                The variance, computed as scale_param x samp_incr.</span>

<span class="sd">            - sign:</span>
<span class="sd">                The sign of samp_incr.</span>

<span class="sd">            - param2/param1:</span>
<span class="sd">                Parameters for the process error distribution.</span>

<span class="sd">            - final_incr:</span>
<span class="sd">                Final simulated incremetnal loss amount after the incorporation of</span>
<span class="sd">                process error.</span>

<span class="sd">            - final_cum:</span>
<span class="sd">                Final simulated cumulative loss amount after the incorporation of</span>
<span class="sd">                process error.</span>

<span class="sd">    tri: trikit.triangle.CumTriangle</span>
<span class="sd">        A cumulative triangle instance.</span>

<span class="sd">    ldfs: pd.Series</span>
<span class="sd">        Loss development factors.</span>

<span class="sd">    scale_param: float</span>
<span class="sd">        The the sum of the squared unscaled Pearson residuals over the triangle&#39;s</span>
<span class="sd">        degrees of freedom.</span>

<span class="sd">    dof: int</span>
<span class="sd">        Triangle degrees of freedom.</span>

<span class="sd">    unscaled_residuals: pd.DataFrame</span>
<span class="sd">        The unscaled residuals.</span>

<span class="sd">    adjusted_residuals: pd.DataFrame</span>
<span class="sd">        The adjusted residuals.</span>

<span class="sd">    sampling_dist: np.ndarray</span>
<span class="sd">        Same as ``adjusted_residuals`` but as a numpy array with NaN&#39;s and 0&#39;s</span>
<span class="sd">        removed. None if ``parametric=True``.</span>

<span class="sd">    fitted_tri_cum: pd.DataFrame</span>
<span class="sd">        Cumulative triangle fit using backwards recursion.</span>

<span class="sd">    fitted_tri_incr: pd.DataFrame</span>
<span class="sd">        Incremental triangle fit using backwards recursion.</span>

<span class="sd">    sims: int</span>
<span class="sd">        Number of bootstrap iterations performed.</span>

<span class="sd">    procdist: str</span>
<span class="sd">        Distribution used to incorporate process variance. Currently &quot;gamma&quot; is</span>
<span class="sd">        the only option.</span>

<span class="sd">    parametric: bool</span>
<span class="sd">        Whether parametric or non-parametric bootstrap was performed.</span>

<span class="sd">    q: float or array_like of float</span>
<span class="sd">        Quantiles over which to evaluate reserve distribution in summary output.</span>

<span class="sd">    interpolation: {&quot;linear&quot;, &quot;lower&quot;, &quot;higher&quot;, &quot;midpoint&quot;, &quot;nearest&quot;}</span>
<span class="sd">        Optional parameter which specifies the interpolation method to use</span>
<span class="sd">        when the desired quantile lies between two data points i &lt; j. See</span>
<span class="sd">        ``numpy.quantile`` for more information. Default value is &quot;linear&quot;.</span>

<span class="sd">    kwargs: dict</span>
<span class="sd">        Additional keyword arguments passed into ``BootstrapChainLadder``&#39;s</span>
<span class="sd">        ``__call__`` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">tri</span><span class="p">,</span> <span class="n">ldfs</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">trisqrd</span><span class="p">,</span> <span class="n">reserve_dist</span><span class="p">,</span> <span class="n">sims_data</span><span class="p">,</span>
                 <span class="n">scale_param</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">unscaled_residuals</span><span class="p">,</span> <span class="n">adjusted_residuals</span><span class="p">,</span>
                 <span class="n">sampling_dist</span><span class="p">,</span> <span class="n">fitted_tri_cum</span><span class="p">,</span> <span class="n">fitted_tri_incr</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">procdist</span><span class="p">,</span>
                 <span class="n">parametric</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">summary</span><span class="o">=</span><span class="n">summary</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="n">tri</span><span class="p">,</span> <span class="n">ldfs</span><span class="o">=</span><span class="n">ldfs</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="n">tail</span><span class="p">,</span>
                         <span class="n">trisqrd</span><span class="o">=</span><span class="n">trisqrd</span><span class="p">,</span> <span class="n">process_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parameter_error</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unscaled_residuals</span> <span class="o">=</span> <span class="n">unscaled_residuals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_residuals</span> <span class="o">=</span> <span class="n">adjusted_residuals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted_tri_incr</span> <span class="o">=</span> <span class="n">fitted_tri_incr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted_tri_cum</span> <span class="o">=</span> <span class="n">fitted_tri_cum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_dist</span> <span class="o">=</span> <span class="n">sampling_dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reserve_dist</span> <span class="o">=</span> <span class="n">reserve_dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_param</span> <span class="o">=</span> <span class="n">scale_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parametric</span> <span class="o">=</span> <span class="n">parametric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sims_data</span> <span class="o">=</span> <span class="n">sims_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">procdist</span> <span class="o">=</span> <span class="n">procdist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sims</span> <span class="o">=</span> <span class="n">sims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="n">dof</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>

        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kk</span><span class="p">])</span>

        <span class="n">qtlsfields</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">ii</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qtlhdrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">ii</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{:,.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">qtlsfields</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_summspecs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtlhdrs</span><span class="p">)</span>

        <span class="c1"># Properties.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_residuals_detail</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_assessment</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_origin_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_agg_dist</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return distribution of bootstrapped ultimates/reserves by origin period.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dist_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;latest&quot;</span><span class="p">,</span> <span class="s2">&quot;ultimate&quot;</span><span class="p">,</span> <span class="s2">&quot;reserve&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_origin_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reserve_dist</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">dist_columns</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin_dist</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residuals_detail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary statistics based on triangle residuals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residuals_detail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametric</span><span class="p">:</span>
                <span class="n">unscaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unscaled_residuals</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">adjusted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjusted_residuals</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">unscaled</span> <span class="o">=</span> <span class="n">unscaled</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unscaled</span><span class="p">)]</span>
                <span class="n">adjusted</span> <span class="o">=</span> <span class="n">adjusted</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">adjusted</span><span class="p">)]</span>
                <span class="n">unscaled</span> <span class="o">=</span> <span class="n">unscaled</span><span class="p">[</span><span class="n">unscaled</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">adjusted</span> <span class="o">=</span> <span class="n">adjusted</span><span class="p">[</span><span class="n">adjusted</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">unscaled_size</span> <span class="o">=</span> <span class="n">unscaled</span><span class="o">.</span><span class="n">size</span>
                <span class="n">unscaled_sum</span> <span class="o">=</span> <span class="n">unscaled</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">unscaled_ssqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unscaled</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">unscaled_min</span> <span class="o">=</span> <span class="n">unscaled</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">unscaled_max</span> <span class="o">=</span> <span class="n">unscaled</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">unscaled_mean</span> <span class="o">=</span> <span class="n">unscaled</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">unscaled_skew</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">unscaled</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span>
                <span class="n">unscaled_mode</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">unscaled</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">unscaled_cvar</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">variation</span><span class="p">(</span><span class="n">unscaled</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span>
                <span class="n">unscaled_kurt</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kurtosis</span><span class="p">(</span><span class="n">unscaled</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span>
                <span class="n">unscaled_var</span> <span class="o">=</span> <span class="n">unscaled</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">unscaled_std</span> <span class="o">=</span> <span class="n">unscaled</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">unscaled_med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">unscaled</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_size</span> <span class="o">=</span> <span class="n">adjusted</span><span class="o">.</span><span class="n">size</span>
                <span class="n">adjusted_sum</span> <span class="o">=</span> <span class="n">adjusted</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_ssqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">adjusted</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_min</span> <span class="o">=</span> <span class="n">adjusted</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_max</span> <span class="o">=</span> <span class="n">adjusted</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_mean</span> <span class="o">=</span> <span class="n">adjusted</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_skew</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">adjusted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span>
                <span class="n">adjusted_mode</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">adjusted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">adjusted_cvar</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">variation</span><span class="p">(</span><span class="n">adjusted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span>
                <span class="n">adjusted_kurt</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kurtosis</span><span class="p">(</span><span class="n">adjusted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span>
                <span class="n">adjusted_var</span> <span class="o">=</span> <span class="n">adjusted</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_std</span> <span class="o">=</span> <span class="n">adjusted</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">adjusted_med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">adjusted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_residuals_detail</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                    <span class="s2">&quot;unscaled&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="n">unscaled_size</span><span class="p">,</span> <span class="n">unscaled_sum</span> <span class="p">,</span> <span class="n">unscaled_ssqr</span><span class="p">,</span> <span class="n">unscaled_min</span><span class="p">,</span>
                        <span class="n">unscaled_max</span><span class="p">,</span> <span class="n">unscaled_mean</span><span class="p">,</span> <span class="n">unscaled_skew</span><span class="p">,</span> <span class="n">unscaled_mode</span><span class="p">,</span>
                        <span class="n">unscaled_cvar</span><span class="p">,</span> <span class="n">unscaled_kurt</span><span class="p">,</span> <span class="n">unscaled_var</span> <span class="p">,</span> <span class="n">unscaled_std</span><span class="p">,</span>
                        <span class="n">unscaled_med</span>
                        <span class="p">],</span>
                    <span class="s2">&quot;adjusted&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="n">adjusted_size</span><span class="p">,</span> <span class="n">adjusted_sum</span> <span class="p">,</span> <span class="n">adjusted_ssqr</span><span class="p">,</span> <span class="n">adjusted_min</span><span class="p">,</span>
                        <span class="n">adjusted_max</span><span class="p">,</span> <span class="n">adjusted_mean</span><span class="p">,</span> <span class="n">adjusted_skew</span><span class="p">,</span> <span class="n">adjusted_mode</span><span class="p">,</span>
                        <span class="n">adjusted_cvar</span><span class="p">,</span> <span class="n">adjusted_kurt</span><span class="p">,</span> <span class="n">adjusted_var</span> <span class="p">,</span> <span class="n">adjusted_std</span><span class="p">,</span>
                        <span class="n">adjusted_med</span>
                        <span class="p">],</span>
                    <span class="p">},</span>
                    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
                        <span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;sum_of_squares&quot;</span><span class="p">,</span> <span class="s2">&quot;minimum&quot;</span><span class="p">,</span> <span class="s2">&quot;maximum&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;skew&quot;</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="s2">&quot;kurtosis&quot;</span><span class="p">,</span> <span class="s2">&quot;variance&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;standard_deviation&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_residuals_detail</span><span class="p">)</span>


<div class="viewcode-block" id="BootstrapChainLadderResult._bs_data_transform"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadderResult._bs_data_transform">[docs]</a>    <span class="k">def</span> <span class="nf">_bs_data_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts with BaseChainLadderResult&#39;s ``_data_transform``, and performs additional</span>
<span class="sd">        pre-processing in order to generate plot of bootstrapped reserve ranges by</span>
<span class="sd">        origin period.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_transform</span><span class="p">()</span>
        <span class="n">data0</span> <span class="o">=</span> <span class="n">data0</span><span class="p">[</span><span class="n">data0</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;total&quot;</span><span class="p">]</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_quantiles_by_devp</span><span class="p">(</span><span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">)</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="n">data1</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;total&quot;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data0</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Remove qtlhdrs values where rectype==&quot;actual&quot;.</span>
        <span class="k">for</span> <span class="n">qtlhdr</span> <span class="ow">in</span> <span class="n">qtlhdrs</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">qtlhdr</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="s2">&quot;actual&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">qtlhdr</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="p">)</span>

        <span class="c1"># Determine the first forecast period by origin, and set q-fields to actuals.</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ldfs</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ldfs</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_ff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="s2">&quot;forecast&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">increment</span>
            <span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_minf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;origin&quot;</span><span class="p">])[</span><span class="s2">&quot;_ff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hdr</span> <span class="ow">in</span> <span class="n">qtlhdrs</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">hdr</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="s2">&quot;forecast&quot;</span><span class="p">,</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_minf&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                    <span class="p">),</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">hdr</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;_ff&quot;</span><span class="p">,</span> <span class="s2">&quot;_minf&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dfv</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;rectype&quot;</span><span class="p">,</span> <span class="s2">&quot;loss&quot;</span><span class="p">]]</span>
        <span class="n">dfl</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;rectype&quot;</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="n">dfu</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;rectype&quot;</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span>
        <span class="n">dfl</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qtlhdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dfl</span> <span class="o">=</span> <span class="n">dfl</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="n">qtlhdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s2">&quot;loss&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfu</span><span class="p">[</span><span class="s2">&quot;rectype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qtlhdrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dfu</span> <span class="o">=</span> <span class="n">dfu</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="n">qtlhdrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="s2">&quot;loss&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dfv</span><span class="p">,</span> <span class="n">dfl</span><span class="p">,</span> <span class="n">dfu</span><span class="p">])</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="BootstrapChainLadderResult._get_quantiles_by_devp"><a class="viewcode-back" href="../../../estimators.html#trikit.estimators.bootstrap.BootstrapChainLadderResult._get_quantiles_by_devp">[docs]</a>    <span class="k">def</span> <span class="nf">_get_quantiles_by_devp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get quantile of boostrapped reserve distribution for an individual origin</span>
<span class="sd">        period and in total.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q: array_like</span>
<span class="sd">            A length-2 sequence representing to upper and lower bounds of</span>
<span class="sd">            the estimated reserve distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dfsims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims_data</span><span class="p">[[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;ultimate&quot;</span><span class="p">]]</span>
        <span class="n">dfults</span> <span class="o">=</span> <span class="n">dfsims</span><span class="p">[</span><span class="n">dfsims</span><span class="o">.</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dfsims</span><span class="o">.</span><span class="n">dev</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dev_increment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ldfs</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ldfs</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dfults</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ldfs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">dev_increment</span>
        <span class="n">dfsims</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dfsims</span><span class="p">,</span> <span class="n">dfults</span><span class="p">])</span>
        <span class="n">dftotal_keys</span> <span class="o">=</span> <span class="n">dfsims</span><span class="p">[</span><span class="n">dfsims</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">dfsims</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">min</span><span class="p">()][[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="n">dftotal_keys</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;total&quot;</span>
        <span class="n">dfqtls_keys</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">dfsims</span><span class="p">[[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(),</span> <span class="n">dftotal_keys</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># Get total reserve across all origin periods.</span>
        <span class="n">dftotal</span> <span class="o">=</span> <span class="n">dfsims</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dftotal</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;total&quot;</span>
        <span class="n">dftotal</span> <span class="o">=</span> <span class="n">dftotal</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">dflist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">):</span>
            <span class="n">dfqtl</span> <span class="o">=</span> <span class="n">dfsims</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">],</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
                <span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">ii</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;ultimate&quot;</span><span class="p">:</span> <span class="n">jj</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
            <span class="n">dftotal_qtl</span> <span class="o">=</span> <span class="n">dftotal</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
                <span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">ii</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;ultimate&quot;</span><span class="p">:</span> <span class="n">jj</span><span class="p">},</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
            <span class="n">dflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dfqtl</span><span class="p">,</span> <span class="n">dftotal_qtl</span><span class="p">]))</span>

        <span class="c1"># Combine DataFrames in dflist into single table.</span>
        <span class="n">dfqtls</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">:</span> <span class="n">df1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">),</span>
            <span class="n">dflist</span><span class="p">,</span> <span class="n">dfqtls_keys</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfqtls</span><span class="p">)</span></div>


<div class="viewcode-block" id="BootstrapChainLadderResult.get_quantiles"><a class="viewcode-back" href="../../../trikit.estimators.html#trikit.estimators.bootstrap.BootstrapChainLadderResult.get_quantiles">[docs]</a>    <span class="k">def</span> <span class="nf">get_quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get quantiles of bootstrapped reserve distribution for an individual origin</span>
<span class="sd">        periods and in total. Returns a DataFrame, with columns representing the</span>
<span class="sd">        percentiles of interest.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q: array_like of float or float</span>
<span class="sd">            Quantile or sequence of quantiles to compute, which must be between 0 and 1</span>
<span class="sd">            inclusive.</span>

<span class="sd">        interpolation: {&quot;linear&quot;, &quot;lower&quot;, &quot;higher&quot;, &quot;midpoint&quot;, &quot;nearest&quot;}</span>
<span class="sd">            Optional parameter which specifies the interpolation method to use</span>
<span class="sd">            when the desired quantile lies between two data points i &lt; j. See</span>
<span class="sd">            ``numpy.quantile`` for more information. Default value is &quot;linear&quot;.</span>

<span class="sd">        lb: float</span>
<span class="sd">            Lower bound of simulated values. If ``lb`` is not None, quantiles less</span>
<span class="sd">            than ``lb`` will be set to ``lb``. To eliminate negative quantiles,</span>
<span class="sd">            set ``lb=0``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">qarr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">qarr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q values must fall within [0, 1].&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qtls_formatter</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>
            <span class="n">qtl_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">qtlhdrs</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">qtls</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qtls</span><span class="p">))]</span>
            <span class="n">dqq</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reserve_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reserve_dist</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">origin</span><span class="p">][</span><span class="s2">&quot;reserve&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                        <span class="mi">100</span> <span class="o">*</span> <span class="n">ii</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span>
                        <span class="p">)</span> <span class="k">for</span> <span class="n">origin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">qtl_pairs</span>
                <span class="p">}</span>
            <span class="n">dfqq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dqq</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dfqq</span> <span class="o">=</span> <span class="n">dfqq</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">lb</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">lb</span> <span class="k">else</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dfqq</span><span class="p">)</span></div>


<div class="viewcode-block" id="BootstrapChainLadderResult.plot"><a class="viewcode-back" href="../../../trikit.estimators.html#trikit.estimators.bootstrap.BootstrapChainLadderResult.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="o">=.</span><span class="mi">90</span><span class="p">,</span> <span class="n">actuals_color</span><span class="o">=</span><span class="s2">&quot;#334488&quot;</span><span class="p">,</span> <span class="n">forecasts_color</span><span class="o">=</span><span class="s2">&quot;#FFFFFF&quot;</span><span class="p">,</span>
             <span class="n">fill_color</span><span class="o">=</span><span class="s2">&quot;#FCFCB1&quot;</span><span class="p">,</span> <span class="n">fill_alpha</span><span class="o">=.</span><span class="mi">75</span><span class="p">,</span> <span class="n">axes_style</span><span class="o">=</span><span class="s2">&quot;darkgrid&quot;</span><span class="p">,</span>
             <span class="n">context</span><span class="o">=</span><span class="s2">&quot;notebook&quot;</span><span class="p">,</span> <span class="n">col_wrap</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hue_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exhibit_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate exhibit representing the distribution of reserve estimates</span>
<span class="sd">        resulting from bootstrap resampling, along with percentiles from the</span>
<span class="sd">        distribution given by ``q``, the percentile(s) of interest.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q: float in range of [0,1]</span>
<span class="sd">            two_sided percentile interval to highlight, which must be between</span>
<span class="sd">            0 and 1 inclusive. For example, when ``q=.90``, the 5th and</span>
<span class="sd">            95th percentile of the ultimate/reserve distribution will be</span>
<span class="sd">            highlighted in the exhibit :math:`(\\frac{1 - q}{2}, \\frac{1 + q}{2})`.</span>

<span class="sd">        actuals_color: str</span>
<span class="sd">            Color or hexidecimal color code used to represent actuals.</span>
<span class="sd">            Defaults to &quot;#00264C&quot;.</span>

<span class="sd">        forecasts_color: str</span>
<span class="sd">            Color or hexidecimal color code used to represent forecasts.</span>
<span class="sd">            Defaults to &quot;#FFFFFF&quot;.</span>

<span class="sd">        fill_color: str</span>
<span class="sd">            Color or hexidecimal color code used to represent the fill color</span>
<span class="sd">            between reserve distribution quantiles associated with ``q``.</span>
<span class="sd">            Defaults to &quot;#FCFCB1&quot;.</span>

<span class="sd">        fill_alpha: float</span>
<span class="sd">            Control transparency of ``fill_color`` between upper and lower</span>
<span class="sd">            percentile bounds of the ultimate/reserve distribution. Defaults</span>
<span class="sd">            to .75.</span>

<span class="sd">        axes_style: {&quot;darkgrid&quot;, &quot;whitegrid&quot;, &quot;dark&quot;, &quot;white&quot;, &quot;ticks&quot;}</span>
<span class="sd">            Aesthetic style of seaborn plots. Default values is &quot;darkgrid&quot;.</span>

<span class="sd">        context: {&quot;notebook&quot;, &quot;paper&quot;, &quot;talk&quot;, &quot;poster&quot;}.</span>
<span class="sd">            Set the plotting context parameters. According to the seaborn</span>
<span class="sd">            documentation, This affects things like the size of the labels,</span>
<span class="sd">            lines, and other elements of the plot, but not the overall style.</span>
<span class="sd">            Default value is &quot;notebook&quot;.</span>

<span class="sd">        col_wrap: int</span>
<span class="sd">            The maximum number of origin period axes to have on a single row</span>
<span class="sd">            of the resulting FacetGrid. Defaults to 5.</span>

<span class="sd">        hue_kws: dictionary of param:list of values mapping</span>
<span class="sd">            Other keyword arguments to insert into the plotting call to let</span>
<span class="sd">            other plot attributes vary across levels of the hue variable</span>
<span class="sd">            (e.g. the markers in a scatterplot). Each list of values should</span>
<span class="sd">            have length 4, with each index representing aesthetic</span>
<span class="sd">            overrides for forecasts, actuals, lower percentile and upper</span>
<span class="sd">            percentile renderings respectively. Defaults to ``None``.</span>

<span class="sd">        exhibit_path: str</span>
<span class="sd">            Path to which exhibit should be written. If None, exhibit will be</span>
<span class="sd">            rendered via ``plt.show()``.</span>

<span class="sd">        kwargs: dict</span>
<span class="sd">            Additional styling options for scatter points. This should include</span>
<span class="sd">            additional options accepted by ``plt.plot``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qtls_formatter</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">two_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bs_data_transform</span><span class="p">(</span><span class="n">qtls</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">])</span>

        <span class="k">with</span> <span class="n">sns</span><span class="o">.</span><span class="n">axes_style</span><span class="p">(</span><span class="n">axes_style</span><span class="p">):</span>
            <span class="n">huekwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">marker</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">markersize</span><span class="o">=</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;#000000&quot;</span><span class="p">,</span> <span class="s2">&quot;#000000&quot;</span><span class="p">,</span> <span class="s2">&quot;#000000&quot;</span><span class="p">,</span> <span class="s2">&quot;#000000&quot;</span><span class="p">],</span>
                <span class="n">fillstyle</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">],</span>
                <span class="n">markerfacecolor</span><span class="o">=</span><span class="p">[</span><span class="n">forecasts_color</span><span class="p">,</span> <span class="n">actuals_color</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">markeredgecolor</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;#000000&quot;</span><span class="p">,</span> <span class="s2">&quot;#000000&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">markeredgewidth</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">50</span><span class="p">,</span> <span class="o">.</span><span class="mi">50</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;-.&quot;</span><span class="p">,</span> <span class="s2">&quot;--&quot;</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">475</span><span class="p">,</span> <span class="o">.</span><span class="mi">475</span><span class="p">,</span> <span class="o">.</span><span class="mi">625</span><span class="p">,</span> <span class="o">.</span><span class="mi">625</span><span class="p">],</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">hue_kws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Determine whether the length of each element of hue_kws is 4.</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hue_kws</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">4</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hue_kws</span><span class="p">):</span>
                    <span class="n">huekwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">hue_kws</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;hue_kws overrides not correct length - Ignoring.&quot;</span><span class="p">)</span>

            <span class="n">grid</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">FacetGrid</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;rectype&quot;</span><span class="p">,</span> <span class="n">hue_kws</span><span class="o">=</span><span class="n">huekwargs</span><span class="p">,</span>
                <span class="n">col_wrap</span><span class="o">=</span><span class="n">col_wrap</span><span class="p">,</span> <span class="n">margin_titles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">despine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">sharex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">hue_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;forecast&quot;</span><span class="p">,</span> <span class="s2">&quot;actual&quot;</span><span class="p">,</span> <span class="n">qtlhdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qtlhdrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="p">)</span>

            <span class="n">ult_vals</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">,</span> <span class="s2">&quot;loss&quot;</span><span class="p">,)</span>
            <span class="n">devp_xticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dev</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
            <span class="n">devp_xticks_str</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">if</span> <span class="n">ii</span> <span class="o">!=</span> <span class="n">devp_xticks</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;ult&quot;</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">devp_xticks</span>
                <span class="p">]</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xticks</span><span class="o">=</span><span class="n">devp_xticks</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">devp_xticks_str</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

                <span class="c1"># Change ticklabel font size and place legend on each facet.</span>
                <span class="k">for</span> <span class="n">origin</span><span class="p">,</span> <span class="n">ax_ii</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span> <span class="n">grid</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>

                    <span class="n">legend</span> <span class="o">=</span> <span class="n">ax_ii</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span>
                        <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;small&quot;</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">fancybox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;#909090&quot;</span><span class="p">,</span>
                        <span class="n">framealpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markerfirst</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>
                    <span class="n">legend</span><span class="o">.</span><span class="n">get_frame</span><span class="p">()</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;#FFFFFF&quot;</span><span class="p">)</span>

                    <span class="c1"># For given origin, determine optimal 5-point tick labels.</span>
                    <span class="n">origin_max_val</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">origin</span><span class="p">]</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">y_ticks</span><span class="p">,</span> <span class="n">y_ticklabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_yticks</span><span class="p">(</span><span class="n">origin_max_val</span><span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">y_ticks</span><span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">y_ticklabels</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                        <span class="n">origin</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">075</span><span class="p">,</span> <span class="o">.</span><span class="mi">90</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">075</span><span class="p">,</span> <span class="o">.</span><span class="mi">90</span><span class="p">),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span>
                        <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#000000&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                    <span class="c1"># Fill between upper and lower range bounds.</span>
                    <span class="n">axc</span> <span class="o">=</span> <span class="n">ax_ii</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span>
                    <span class="n">lines_</span> <span class="o">=</span> <span class="p">[</span><span class="n">jj</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">axc</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">)]</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="p">[</span><span class="n">jj</span><span class="o">.</span><span class="n">_x</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">lines_</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jj</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">yy</span> <span class="o">=</span> <span class="p">[</span><span class="n">jj</span><span class="o">.</span><span class="n">_y</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">lines_</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jj</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">x_</span><span class="p">,</span> <span class="n">lb_</span><span class="p">,</span> <span class="n">ub_</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yy</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">yy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">lb_</span><span class="p">,</span> <span class="n">ub_</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">fill_alpha</span><span class="p">)</span>

                    <span class="c1"># Draw border around each facet.</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">spine_</span> <span class="ow">in</span> <span class="n">ax_ii</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">spine_</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#000000&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=.</span><span class="mi">50</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">exhibit_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">exhibit_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="BootstrapChainLadderResult.hist"><a class="viewcode-back" href="../../../trikit.estimators.html#trikit.estimators.bootstrap.BootstrapChainLadderResult.hist">[docs]</a>    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#FFFFFF&quot;</span><span class="p">,</span> <span class="n">axes_style</span><span class="o">=</span><span class="s2">&quot;darkgrid&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="s2">&quot;notebook&quot;</span><span class="p">,</span>
             <span class="n">col_wrap</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">exhibit_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate histogram of estimated reserve distribution by accident</span>
<span class="sd">        year and in total.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        color: str</span>
<span class="sd">            Determines histogram color in each facet. Can also be specified as</span>
<span class="sd">            a key-value pair in ``kwargs``.</span>
<span class="sd">        axes_style: str</span>
<span class="sd">            Aesthetic style of plots. Defaults to &quot;darkgrid&quot;. Other options</span>
<span class="sd">            include {whitegrid, dark, white, ticks}.</span>

<span class="sd">        context: str</span>
<span class="sd">            Set the plotting context parameters. According to the seaborn</span>
<span class="sd">            documentation, This affects things like the size of the labels,</span>
<span class="sd">            lines, and other elements of the plot, but not the overall style.</span>
<span class="sd">            Defaults to ``&quot;notebook&quot;``. Additional options include</span>
<span class="sd">            {paper, talk, poster}.</span>

<span class="sd">        col_wrap: int</span>
<span class="sd">            The maximum number of origin period axes to have on a single row</span>
<span class="sd">            of the resulting FacetGrid. Defaults to 5.</span>

<span class="sd">        exhibit_path: str</span>
<span class="sd">            Path to which exhibit should be written. If None, exhibit will be</span>
<span class="sd">            rendered via ``plt.show()``.</span>

<span class="sd">        kwargs: dict</span>
<span class="sd">            Dictionary of optional matplotlib styling parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="c1"># data0 = self.sims_data[[&quot;sim&quot;, &quot;origin&quot;, &quot;dev&quot;, &quot;rectype&quot;, &quot;latest&quot;, &quot;reserve&quot;,]]</span>
        <span class="c1"># data0 = data0[(data0[&quot;dev&quot;]==data0[&quot;dev&quot;].max()) &amp; (data0[&quot;rectype&quot;]==&quot;forecast&quot;)].reset_index(drop=True)</span>
        <span class="c1"># data0 = data0.drop([&quot;dev&quot;, &quot;rectype&quot;, &quot;latest&quot;], axis=1)</span>
        <span class="c1">#</span>
        <span class="c1"># # Include additional origin representing aggregate distribution.</span>
        <span class="c1"># data1 = data0.groupby(&quot;sim&quot;, as_index=False)[[&quot;reserve&quot;]].sum()</span>
        <span class="c1"># data1[&quot;origin&quot;] =&quot;total&quot;</span>
        <span class="c1"># data = pd.concat([data0, data1])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reserve_dist</span>

        <span class="c1"># Get mean, min and max ultimate and reserve by origin.</span>
        <span class="n">med_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;reserve&quot;</span><span class="p">:</span> <span class="s2">&quot;med_res&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">)</span>
        <span class="n">min_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;reserve&quot;</span><span class="p">:</span> <span class="s2">&quot;min_res&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">)</span>
        <span class="n">max_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[[</span><span class="s2">&quot;reserve&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;reserve&quot;</span><span class="p">:</span> <span class="s2">&quot;max_res&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">)</span>
        <span class="n">dfmetrics</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">:</span> <span class="n">df1</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df2</span><span class="p">),</span> <span class="p">(</span><span class="n">med_data</span><span class="p">,</span> <span class="n">min_data</span><span class="p">,</span> <span class="n">max_data</span><span class="p">))</span>
        <span class="n">dfmetrics</span> <span class="o">=</span> <span class="n">dfmetrics</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">sns</span><span class="o">.</span><span class="n">axes_style</span><span class="p">(</span><span class="n">axes_style</span><span class="p">):</span>

            <span class="n">pltkwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">color</span><span class="p">,</span> <span class="s2">&quot;bins&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;edgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;#484848&quot;</span><span class="p">,</span>
                         <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="o">.</span><span class="mi">45</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pltkwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">grid</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">FacetGrid</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="n">col_wrap</span><span class="o">=</span><span class="n">col_wrap</span><span class="p">,</span> <span class="n">margin_titles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">despine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">hists</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="s2">&quot;reserve&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">pltkwargs</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">set_axis_labels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">set_titles</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

            <span class="c1"># Change ticklabel font size and place legend on each facet.</span>
            <span class="n">origin_vals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span> <span class="k">if</span> <span class="n">ii</span> <span class="o">!=</span> <span class="s2">&quot;total&quot;</span><span class="p">])</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="p">{</span><span class="n">jj</span><span class="p">:</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">origin_vals</span><span class="p">)}</span>
            <span class="n">dindex</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">dindex</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;origin_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">dindex</span><span class="p">)</span>
            <span class="n">origin_order</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s2">&quot;origin_index&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="s2">&quot;origin_index&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">values</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">origin</span><span class="p">,</span> <span class="n">ax_ii</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">origin_order</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>

                    <span class="c1"># xmin = np.max([0, dfmetrics[dfmetrics.origin == origin][&quot;min_res&quot;].item()])</span>
                    <span class="n">xmax</span> <span class="o">=</span> <span class="n">dfmetrics</span><span class="p">[</span><span class="n">dfmetrics</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">origin</span><span class="p">][</span><span class="s2">&quot;max_res&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1.025</span>
                    <span class="n">xmed</span> <span class="o">=</span> <span class="n">dfmetrics</span><span class="p">[</span><span class="n">dfmetrics</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">origin</span><span class="p">][</span><span class="s2">&quot;med_res&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="n">origin_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">xmed</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#E02C70&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                    <span class="n">ymedloc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span> <span class="k">for</span> <span class="n">rect</span> <span class="ow">in</span> <span class="n">ax_ii</span><span class="o">.</span><span class="n">patches</span><span class="p">)</span> <span class="o">*</span> <span class="o">.</span><span class="mi">30</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([])</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span>
                        <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span>
                        <span class="p">[</span><span class="s2">&quot;</span><span class="si">{:,.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ax_ii</span><span class="o">.</span><span class="n">get_xticks</span><span class="p">()],</span> <span class="n">size</span><span class="o">=</span><span class="mi">7</span>
                        <span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                        <span class="n">origin_str</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">85</span><span class="p">,</span> <span class="o">.</span><span class="mi">925</span><span class="p">),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span>
                        <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#000000&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">ax_ii</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                        <span class="s2">&quot;median = </span><span class="si">{:,.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xmed</span><span class="p">),</span> <span class="p">(</span><span class="n">xmed</span><span class="p">,</span> <span class="n">ymedloc</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mf">7.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                        <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                        <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#000000&quot;</span>
                        <span class="p">)</span>

                    <span class="c1"># Draw border around each facet.</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">spine</span> <span class="ow">in</span> <span class="n">ax_ii</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">spine</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#000000&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=.</span><span class="mi">50</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">exhibit_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">exhibit_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018, James D. Triveri

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>